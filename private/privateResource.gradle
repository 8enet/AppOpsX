apply from: "../private/env.gradle"
apply from: "../private/utils.gradle"

import java.nio.file.Files
import java.nio.file.StandardCopyOption

def getGitHash = { ->
    def stdout = new ByteArrayOutputStream()
    exec {
        commandLine 'git', 'rev-parse', '--short', 'HEAD'
        standardOutput = stdout
    }
    return stdout.toString().trim()
}

ext {
    JEK_FILE_DECRYPTED = rootProject.file("private/myapp.jks")
    GIT_COMMIT_ID = getGitHash()
    BUILD_SUFFIX = "v${VERSION_NAME}-${new Date().format("yyyyMMdd")}-${GIT_COMMIT_ID}"
}


task releaseSigningConfigs {

    println("-----releaseSigningConfigs----")
    def jksPwd = project.myEnv.JKS_PWD
    if (checkEmpty(jksPwd, project.myEnv.JKS_FILE)) {
        println("sign config error!!")
        return
    }

    def data = aesDecrypt(file(rootProject.file(project.myEnv.JKS_FILE)).bytes, jksPwd.getBytes())

    if (data == null) {
        println("decrypt file ${project.myEnv.JKS_FILE} error!")
        return
    }
    JEK_FILE_DECRYPTED.withOutputStream {
        it.write(data)
    }

}


task pushApkFile {

    doLast {

        println("-----pushApkFile----")


        def sourceApk = project.file("build/outputs/apk/release/app-release.apk")

        if (!sourceApk.exists()) {
            println("release apk not found !")
            return
        }

        def apk = project.file("appopsx-${BUILD_SUFFIX}.apk")

        Files.copy(sourceApk.toPath(), apk.toPath(), StandardCopyOption.REPLACE_EXISTING)
        println("${apk} md5:" + md5File(apk))

        postFile(apk)
    }

}



task releaseResource {
    doLast {
        JEK_FILE_DECRYPTED.delete()
    }
}

tasks.whenTaskAdded { task ->
    println("$task.name")
    if (task.name == "assembleRelease") {
        task.finalizedBy(pushApkFile,releaseResource)
    }
}
